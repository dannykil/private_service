# ====================================== AIRFLOW ENVIRONMENT VARIABLES =======================================
x-environment: &airflow_environment # Airflow settings.
  - AIRFLOW__CORE__EXECUTOR=LocalExecutor
  - AIRFLOW__CORE__LOAD_DEFAULT_CONNECTIONS=False
  - AIRFLOW__CORE__LOAD_EXAMPLES=False
  - AIRFLOW__CORE__SQL_ALCHEMY_CONN=postgresql://airflow:airflow@airflow-postgres:5432/airflow
  - AIRFLOW__CORE__STORE_DAG_CODE=True
  - AIRFLOW__CORE__STORE_SERIALIZED_DAGS=True
  - AIRFLOW__WEBSERVER__EXPOSE_CONFIG=True
  - AIRFLOW__WEBSERVER__RBAC=False
  # Movielens API settings.
  - AIRFLOW_CONN_MOVIELENS=http://airflow:airflow@movielens
  - MOVIELENS_USER=airflow
  - MOVIELENS_PASSWORD=airflow
# x-airflow-image: &airflow_image apache/airflow:2.0.0-python3.8
x-airflow-image: &airflow_image apache/airflow:2.10.5-python3.11
# ====================================== /AIRFLOW ENVIRONMENT VARIABLES ======================================

# # 모든 Airflow 컨테이너 시작
# docker compose --profile airflow up -d

# # 모든 Airflow 컨테이너 종료 및 삭제
# docker compose --profile airflow down

# # 상태 확인
# docker compose --profile airflow ps

services:
  qdrant:
    # Qdrant 공식 Docker 이미지 사용
    image: qdrant/qdrant:latest
    container_name: qdrant_server

    # 서버와 웹 UI 포트를 호스트 머신에 바인딩
    ports:
      - '6333:6333' # Qdrant API 포트 (데이터 통신)
      - '6334:6334' # Qdrant Web UI 포트 (시각화 대시보드)

    # 데이터 영속성을 위한 설정
    volumes:
      # 1. 벡터 데이터 및 인덱스 저장
      # 로컬 qdrant_storage 폴더와 컨테이너 내부의 /qdrant/storage 폴더를 연결합니다.
      - ./qdrant/storage:/qdrant/storage
      # 2. 서버 설정 파일 저장 (선택 사항이지만 권장)
      - ./qdrant/config:/qdrant/config
    profiles:
      - llm

  # qdrant-postgres:
  #   image: postgres:15-alpine
  #   container_name: qdrant-postgres
  #   environment:
  #     # 비밀번호, 사용자, DB 이름 설정 (코드가 이 정보를 사용함)
  #     POSTGRES_USER: user
  #     POSTGRES_PASSWORD: password
  #     POSTGRES_DB: langchain_db
  #   ports:
  #     - '5432:5432'
  #   volumes:
  #     # 데이터 영속성을 위한 볼륨 설정
  #     - ./qdrant/postgres_data:/var/lib/postgresql/data
  #   profiles:
  #     - llm

  postgres-vector:
    image: pgvector/pgvector:pg15
    container_name: postgres-vector
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: langchain_db
      POSTGRES_INITDB_ARGS: '-E UTF8'
    ports:
      - '5432:5432'
    volumes:
      - ./qdrant/postgres_data:/var/lib/postgresql/data
      - ./qdrant/init.sql:/docker-entrypoint-initdb.d/init.sql # 추가
    command: postgres -c 'port=5432'
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U user -d langchain_db']
      interval: 5s
      timeout: 5s
      retries: 5
    profiles:
      - llm

  airflow-postgres:
    image: postgres:12-alpine
    # image: postgres:15-alpine
    container_name: airflow-postgres
    environment:
      - POSTGRES_USER=airflow
      - POSTGRES_PASSWORD=airflow
      - POSTGRES_DB=airflow
    ports:
      - '5432:5432'
    volumes:
      - ./airflow/postgres-data:/var/lib/postgresql/data
    networks:
      - airflow-network
    profiles:
      - airflow

  airflow-init:
    build:
      context: ./airflow/docker/airflow-data
      args:
        AIRFLOW_BASE_IMAGE: *airflow_image
    image: airflow-custom:latest
    container_name: airflow-init
    depends_on:
      - airflow-postgres
    environment: *airflow_environment
    entrypoint: /bin/bash
    command: -c 'airflow db upgrade && sleep 5 && airflow users create --username admin --password admin --firstname Anonymous --lastname Admin --role Admin --email admin@example.org'
    networks:
      - airflow-network
    profiles:
      - airflow

  airflow-webserver:
    image: airflow-custom:latest
    container_name: airflow-webserver
    depends_on:
      - airflow-postgres
      - airflow-init
    ports:
      # - '8080:8080'
      - '8000:8080'
    volumes:
      - ./airflow/logs:/opt/airflow/logs
    environment: *airflow_environment
    command: webserver
    networks:
      - airflow-network
    profiles:
      - airflow

  airflow-scheduler:
    image: airflow-custom:latest
    container_name: airflow-scheduler
    depends_on:
      - airflow-postgres
      - airflow-init
    volumes:
      # - ./airflow/dags:/opt/airflow/dags
      - /Users/danniel.kil/Documents/workspace/search-admin/airflow/dags:/opt/airflow/dags
      - ./airflow/data:/data
      - ./airflow/logs:/opt/airflow/logs
      - /var/run/docker.sock:/var/run/docker.sock # Docker 소켓 마운트
      - /tmp/airflow/data:/tmp/airflow/data # 작업 데이터 디렉토리
    environment: *airflow_environment
    command: scheduler
    networks:
      - airflow-network
    profiles:
      - airflow

  redis:
    image: redis:7-alpine # 가볍고 안정적인 Redis 이미지 사용
    container_name: redis_server
    ports:
      - '6379:6379' # Redis 기본 포트
    volumes:
      # Redis 데이터 영속성 설정
      # 1. 데이터 파일 저장 경로 연결 (Redis 기본 AOF 파일)
      - ./redis/redis_data:/data
    command: redis-server --appendonly yes # AOF(Append Only File) 영속성 활성화
    # restart: always
    profiles:
      - redis

  prometheus:
    image: prom/prometheus
    container_name: prometheus
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml # 경로 수정
      # - prometheus_data:/prometheus # 프로메테우스 데이터 볼륨 추가
      - ./prometheus/data:/prometheus # 프로메테우스 데이터 경로 변경
    ports:
      - '9090:9090'
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      # - --web.enable-admin-api
      # - --web.enable-lifecycle
      # # - --config.file=/etc/prometheus/prometheus.yml
      # - --storage.tsdb.path=/prometheus
      # - --web.console.libraries=/usr/share/prometheus/console_libraries
      # - --web.console.templates=/usr/share/prometheus/consoles
    restart: unless-stopped
    profiles:
      - monitoring

  grafana:
    image: grafana/grafana
    container_name: grafana
    ports:
      - '3000:3000'
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      # - GF_SECURITY_ADMIN_PASSWORD=my_admin_password
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      # - grafana_data:/var/lib/grafana # 그라파나 데이터 볼륨 추가
      - ./grafana/data:/var/lib/grafana # 그라파나 데이터 경로 변경
    depends_on:
      - prometheus
    restart: unless-stopped
    profiles:
      - monitoring

  jenkins:
    build:
      context: ./jenkins
      dockerfile: ./jenkins/Dockerfile # Dockerfile 경로 지정
    image: jenkins/jenkins:lts
    container_name: jenkins
    ports:
      - '8080:8080'
      # - '8081:8080' # 8081번 포트를 사용하도록 변경
      - '50000:50000'
    environment:
      # 호스트에서 확인한 Docker 그룹의 GID로 교체하세요. (예: 999)
      - DOCKER_GID=999
    volumes:
      - ./jenkins/data:/var/jenkins_home # 로컬
      # - jenkins_home:/var/jenkins_home # 서버
      # Docker-in-Docker 기능을 위한 설정
      - /var/run/docker.sock:/var/run/docker.sock # Docker 소켓 마운트
      - /usr/bin/docker:/usr/bin/docker # Docker 바이너리
      - /usr/local/bin/docker-compose:/usr/local/bin/docker-compose # Docker Compose 바이너리
      # - /usr/bin/docker-compose:/usr/bin/docker-compose # Docker Compose 바이너리
    #   restart: unless-stopped
    profiles:
      - jenkins

  gitlab:
    build:
      context: ./gitlab
      dockerfile: ./gitlab/Dockerfile
    image: gitlab/gitlab-ce:18.4.2-ce.0
    container_name: gitlab
    hostname: 'localhost'
    ports:
      - '443:443'
      - '80:80'
      - '22:22'
    volumes:
      - ./gitlab/config:/etc/gitlab
      - ./gitlab/logs:/var/log/gitlab
      - ./gitlab/data:/var/opt/gitlab
    shm_size: '256m'
    # restart: always
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        gitlab_rails['smtp_enable'] = true;
        gitlab_rails['smtp_address'] = "smtp.gmail.com";
        gitlab_rails['smtp_port'] = 587;
        gitlab_rails['smtp_user_name'] = "danniel.kil@gmail.com";
        gitlab_rails['smtp_password'] = "eaif ruwc neky jzxh";
        gitlab_rails['smtp_domain'] = "gmail.com";
        gitlab_rails['smtp_authentication'] = "login";
        gitlab_rails['smtp_enable_starttls_auto'] = true;
        gitlab_rails['gitlab_email_enabled'] = true;
        gitlab_rails['gitlab_email_from'] = "gitlab_admin_63500f@example.com";
        gitlab_rails['gitlab_email_display_name'] = 'GitLab';
        external_url 'http://localhost';
    profiles:
      - gitlab

  # Kong Gateway Database
  kong-database:
    image: postgres:13
    container_name: kong-database
    networks:
      - kong-net
    environment:
      POSTGRES_USER: kong
      POSTGRES_DB: kong
      POSTGRES_PASSWORD: kong
    command: -c max_connections=200
    volumes:
      # - ./kong_gateway/data:/var/lib/postgresql/data
      - /my/db/path:/var/lib/postgresql/data # 기존 서버 데이터베이스 경로
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U kong -d kong']
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    restart: unless-stopped
    profiles:
      - kong

  # Kong Migration (데이터베이스 초기화)
  kong-migration:
    build:
      context: ./kong_gateway
      dockerfile: Dockerfile
    image: kong-custom:latest
    container_name: kong-migration
    networks:
      - kong-net
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
    command: kong migrations bootstrap
    depends_on:
      kong-database:
        condition: service_healthy
    restart: on-failure
    profiles:
      - kong

  # Kong Gateway
  kong-gateway:
    image: kong-custom:latest
    container_name: kong-gateway
    networks:
      - kong-net
    ports:
      - '8020:8000'
      - '8443:8443'
      - '8030:8030'
      - '8444:8444'
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8030
    depends_on:
      kong-database:
        condition: service_healthy
      kong-migration:
        condition: service_completed_successfully
    restart: unless-stopped
    profiles:
      - kong

  # Kong Manager (UI)
  kong-manager:
    image: kong-custom:latest
    container_name: kong-manager
    networks:
      - kong-net
    ports:
      - '22222:22222'
      - '8445:8445'
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
      KONG_ADMIN_LISTEN: 0.0.0.0:8030,0.0.0.0:8444 ssl
      KONG_ADMIN_GUI_LISTEN: 0.0.0.0:22222,0.0.0.0:8445 ssl
    depends_on:
      kong-database:
        condition: service_healthy
      kong-migration:
        condition: service_completed_successfully
    restart: unless-stopped
    profiles:
      - kong

  n8n:
    image: n8nio/n8n:latest
    container_name: n8n
    ports:
      - '5678:5678' # n8n 웹 인터페이스 포트
    environment:
      # 기본 설정
      - N8N_BASIC_AUTH_ACTIVE=true
      - N8N_BASIC_AUTH_USER=admin
      - N8N_BASIC_AUTH_PASSWORD=admin
      # 타임존 설정
      - GENERIC_TIMEZONE=Asia/Seoul
      - TZ=Asia/Seoul
      # 데이터 저장 경로
      - N8N_USER_FOLDER=/home/node/.n8n
      # 워크플로우 실행 데이터 저장
      - EXECUTIONS_DATA_SAVE_ON_SUCCESS=all
      - EXECUTIONS_DATA_SAVE_ON_ERROR=all
      - EXECUTIONS_DATA_SAVE_ON_PROGRESS=true
      - EXECUTIONS_DATA_SAVE_MANUAL_EXECUTIONS=true
    volumes:
      # n8n 데이터 영속성 설정 (워크플로우, 자격증명, 실행 데이터 등)
      - ./n8n/data:/home/node/.n8n
    restart: unless-stopped
    profiles:
      - n8n

  portainer: # admin // administrator
    image: portainer/portainer-ce:latest
    container_name: portainer
    ports:
      - '9000:9000' # Portainer 웹 UI 포트
      - '9443:9443' # Portainer HTTPS 포트
      - '8050:8000' # Edge Agent 포트 (선택사항)
    volumes:
      # Portainer 데이터 영속성 설정 (설정, 사용자, 템플릿 등)
      - ./portainer/data:/data
      # Docker 소켓 마운트 (Docker 환경 관리를 위해 필수)
      - /var/run/docker.sock:/var/run/docker.sock
    restart: unless-stopped
    profiles:
      - portainer

  # statsd_exporter:
  #   image: prom/statsd-exporter:v0.18.0
  #   restart: always
  #   volumes:
  #     - ./airflow/files/statsd_mapping.yml:/tmp/statsd_mapping.yml
  #   ports:
  #     - '9102:9102'
  #     - '9125:9125/udp'
  #   command: --statsd.mapping-config=/tmp/statsd_mapping.yml

  # open-webui:
  #   # image: my-open-webui:latest
  #   build: ./open_web_ui # Dockerfile이 현재 디렉터리에 있음을 의미
  #   ports:
  #     - '4000:8080'
  #   volumes:
  #     - ./open_web_ui/data:/app/backend/data # Open WebUI 데이터 볼륨
  #   restart: unless-stopped

  # ====================================== OLLAMA SERVICE =======================================
  # Ollama - Local LLM Model Serving
  # Profile: llm
  # Start: docker compose --profile llm up -d
  # Stop: docker compose --profile llm down
  # Access: http://localhost:11434
  # Pull models: docker exec -it ollama ollama pull llama2
  # ====================================== /OLLAMA SERVICE ======================================

  ollama:
    # image: ollama/ollama:latest
    build:
      context: ./ollama
      dockerfile: Dockerfile
    image: ollama/ollama:latest
    container_name: ollama
    ports:
      - '11434:11434' # Ollama API 포트
    environment:
      # Ollama 설정
      - OLLAMA_HOST=0.0.0.0
      # GPU 메모리 제한 설정 (선택 사항)
      # - OLLAMA_MAX_LOADED_MODELS=1
      # - OLLAMA_NUM_PARALLEL=1
    volumes:
      # Ollama 데이터 영속성 설정 (모델, 설정 등)
      - ./ollama/data:/root/.ollama
    restart: unless-stopped
    profiles:
      - llm
    # Ollama가 GPU를 사용하도록 설정 (NVIDIA GPU가 있는 경우)
    # deploy:
    #   resources:
    #     reservations:
    #       devices:
    #         - driver: nvidia
    #           count: all
    #           capabilities: [gpu]

networks:
  airflow-network:
    driver: bridge
  kong-net:
    driver: bridge
  dify-network:
    driver: bridge

volumes:
  jenkins_home: # Jenkins 데이터 볼륨(서버전용, 로컬에서는 사용안함)
    external: true # 기존에 존재하는 jenkins_home 볼륨 사용
#   prometheus_data:
#   grafana_data:
